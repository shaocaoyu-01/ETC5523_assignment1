<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Caoyu Shao">
<meta name="dcterms.date" content="2025-08-24">

<title>ETC5523: Communication with Data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Assignment_1_files/libs/clipboard/clipboard.min.js"></script>
<script src="Assignment_1_files/libs/quarto-html/quarto.js"></script>
<script src="Assignment_1_files/libs/quarto-html/popper.min.js"></script>
<script src="Assignment_1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Assignment_1_files/libs/quarto-html/anchor.min.js"></script>
<link href="Assignment_1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Assignment_1_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Assignment_1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Assignment_1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Assignment_1_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ETC5523: Communication with Data</h1>
<p class="subtitle lead">Assignment 1: Example breakdown of article</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Caoyu Shao </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 24, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="piece-1-list-aprint-media" class="level2">
<h2 class="anchored" data-anchor-id="piece-1-list-aprint-media">Piece 1 — List A(Print media)</h2>
<p><strong>Title</strong>: Mapping Australia’s childcare blackspots(ABC News)</p>
<p><strong>Links</strong>: <a href="https://www.abc.net.au/news/2022-03-22/mapping-australia-s-childcare-blackspots/100894808?utm_campaign=abc_news_web&amp;utm_content=link&amp;utm_medium=content_shared&amp;utm_source=abc_news_web" class="uri">https://www.abc.net.au/news/2022-03-22/mapping-australia-s-childcare-blackspots/100894808?utm_campaign=abc_news_web&amp;utm_content=link&amp;utm_medium=content_shared&amp;utm_source=abc_news_web</a></p>
<p><strong>Two-sentense summary</strong>: Australia has serious geographical inequality in access to childcare and over one-third of Australians live in “childcare deserts”. The article starts with an family story and show interactive maps to show deserts concentrate on city fringes and regional areas while “oases” cluster in wealthier inner suburbs in large cities.</p>
<p><strong>Lede</strong>: At the end of the article, there is a box and we could input our residential address and get the scarcity of child care resources nearby, which is very rare in the online articles. But it is becoming more and more frequent because it could enhance the readers’ sense of participation.</p>
<p>The background information in the middle of the article:</p>
<blockquote class="blockquote">
<p>The data from the Mitchell Institute for Education and Health Policy at Victoria University, supplied exclusively to the ABC, found stark geographical divides in access to child care. The project was partially funded by the Minderoo Foundation as part of the <a href="https://www.minderoo.org/thrive-by-five/%C2%A0">Thrive by Five initiative</a>.</p>
</blockquote>
<blockquote class="blockquote">
<p>Child care is critical to women’s employment. This,&nbsp;in turn, drives economic growth, boosts financial security and improves social and health outcomes for women and families.</p>
</blockquote>
<blockquote class="blockquote">
<p>Ultimately, if people can’t get the child care they need, they’re not going to be able to work, Dr Hurley says.</p>
</blockquote>
<p><strong>Background</strong>: What the Mitchell Institute measured. It provides the proof of our main results——National maps and key numbers and determines the scope of statistical scope. Why childcare access matters for work, equity and early learning, it indicates the importance and necessity of the article.</p>
<p>The main result in the middle of the article:</p>
<blockquote class="blockquote">
<p>“The key finding is that where you live matters when it comes to access to child care,” says Peter Hurley, a Mitchell Institute education policy fellow and lead author of the report.</p>
</blockquote>
<blockquote class="blockquote">
<p>The heat maps about major cities in the article</p>
</blockquote>
<p><strong>Main result</strong>: National maps +key numbers. The maps have straightforward illustrated the inequality of children care access.</p>
<p>The summary in the middle of the article:</p>
<blockquote class="blockquote">
<p>Sprawling deserts, scattered oases</p>
</blockquote>
<blockquote class="blockquote">
<p>Higher supply, higher fees</p>
</blockquote>
<p><strong>Summary</strong>: Re‑anchors to inequality; policy takeaways.</p>
</section>
<section id="piece-2-list-bblog-post" class="level2">
<h2 class="anchored" data-anchor-id="piece-2-list-bblog-post">Piece 2 — List B(Blog post)</h2>
<p><strong>Title</strong>: How does ChatGPT work? As explained by the ChatGPT team — The Pragmatic Engineer.</p>
<p><strong>Link：</strong><a href="https://newsletter.pragmaticengineer.com/p/scaling-chatgpt?ref=blog.pragmaticengineer.com" class="uri">https://newsletter.pragmaticengineer.com/p/scaling-chatgpt?ref=blog.pragmaticengineer.com</a></p>
<p>The summary in the middle of the article:</p>
<blockquote class="blockquote">
<p>Input. We take your text from the text input.</p>
</blockquote>
<blockquote class="blockquote">
<p>Tokenization. We chunk it into tokens. A token roughly maps to a couple of unicode characters. You can think of it as a word.</p>
</blockquote>
<blockquote class="blockquote">
<p>Create embeddings. We turn each token into a vector of numbers. These are called embeddings.</p>
</blockquote>
<blockquote class="blockquote">
<p>Multiply embeddings by model weights. We then multiply these embeddings by hundreds of billions of model weights.</p>
</blockquote>
<blockquote class="blockquote">
<p>Sample a prediction. At the end of this multiplication, the vector of numbers represents the probability of the next most likely token. That next most likely token are the next few characters that spit out of ChatGPT.</p>
</blockquote>
<p><strong>Two sentence summary:</strong> This post is a Q&amp;A with an OpenAI engineering explaining how ChatGPT works. It uses respond pipelines and five-step graphs to demystify large language models for the general people.</p>
<p>The background information in the middle of the article:</p>
<blockquote class="blockquote">
<p>Sometimes the best explanations of how a technology solution works come from the software engineers who built it. To explain how ChatGPT (and other large language models) operate, I turned to the ChatGPT engineering team.</p>
</blockquote>
<blockquote class="blockquote">
<p>I asked this from Evan Morikawa at OpenAI. Evan joined OpenAI in 2020 – two years before ChatGPT launched – and has led the Applied engineering team as ChatGPT launched and scaled. His team was the one that created ChatGPT, and Evan has been there from the very beginning.</p>
</blockquote>
<p><strong>Background:</strong> Who the interviewee is&amp; Why interview him, this could enhance the credibility of the post blog by stating the importance of interviewee. Context on the definitions, this could help the readers understand easily because it use plain words to explain abstract concepts.</p>
<p><strong>Lede</strong>: Author prepares the interview and launch it with the form of Q&amp;A instead of article. Besides the Q&amp;A enumerate the steps plainly, like input, tokenisation, create embeddings, multiply embeddings by model weights, sample a prediction. As a reader without any relevant knowledge, we could simply know how LLM works.</p>
<p>This is the main result in the article:</p>
<blockquote class="blockquote">
<p>Input. We take your text from the text input.</p>
</blockquote>
<blockquote class="blockquote">
<p>Tokenization. We chunk it into tokens. A token roughly maps to a couple of unicode characters. You can think of it as a word.</p>
</blockquote>
<blockquote class="blockquote">
<p>Create embeddings. We turn each token into a vector of numbers. These are called embeddings.</p>
</blockquote>
<blockquote class="blockquote">
<p>Multiply embeddings by model weights. We then multiply these embeddings by hundreds of billions of model weights.</p>
</blockquote>
<blockquote class="blockquote">
<p>Sample a prediction. At the end of this multiplication, the vector of numbers represents the probability of the next most likely token. That next most likely token are the next few characters that spit out of ChatGPT.</p>
</blockquote>
<blockquote class="blockquote">
<p>How do we generate this complex set of model weights, whose values encode most of human knowledge? We do it through a process called pretraining.</p>
</blockquote>
<blockquote class="blockquote">
<p>Once we have our model we can run inference on it, which is when we prompt the model with text. It makes this prediction based on past input, and it happens repeatedly, token by token, word by word, until it spits out your post!</p>
</blockquote>
<p><strong>Main result</strong>: Five steps of pipelines(input, tokenisations , embeddings , matrix , multisampling); Pretraining and inference.</p>
<p>This is the summary of the article:</p>
<blockquote class="blockquote">
<p>How ChatGPT works isn’t magic, and is worth understanding.</p>
</blockquote>
<p><strong>Summary:</strong> How ChatGPT works isn’t magic, and is worth understanding</p>
</section>
<section id="piece-3-list-cvideo" class="level2">
<h2 class="anchored" data-anchor-id="piece-3-list-cvideo">Piece 3 — List C(Video)</h2>
<p><strong>Title</strong> : Why I fell in love with monster prime numbers —–Adam Spencer(TED)</p>
<p><strong>Link</strong>: <a href="https://www.youtube.com/watch?v=B4xOFsygwr4" class="uri">https://www.youtube.com/watch?v=B4xOFsygwr4</a></p>
<p><strong>Two-sentence summary</strong>: A lively talk uses record-prime hunts to convey the wonder of mathematics and collaborative computation. Humor and visuals make a huge, abstract number feel tangible and exciting.</p>
<p><strong>Background</strong>: What primes number is, it provide the mathematical foundation of audience so that they could get the talk show; Why the large prime number matter, it tells the audience the importance of the speech.</p>
<p><strong>Lade</strong>: Highly academic content can be presented in the form of a talk show. In our impression, talk shows seem to be very relaxed, while academics are very serious. But Adam combined the two together. In fact, this kind of talk show could reduce our cognitive loads.</p>
<p><strong>Main result</strong>: Stories/ visuals of record primes.</p>
<p><strong>Summary</strong>: Inspire curiosity; invites ongoing discovery</p>
</section>
<section id="combined-reflection" class="level2">
<h2 class="anchored" data-anchor-id="combined-reflection">Combined reflection</h2>
<section id="difference" class="level3">
<h3 class="anchored" data-anchor-id="difference">Difference</h3>
<ol type="1">
<li><strong>Openings:</strong> News initiated with an empathetic vignette; the blog starts with an authority hand-off; the talk uses performance energy.</li>
<li><strong>Summaries:</strong> The news use a interactive map to illustrate the conclusion; the blog post uses five steps of pipelines to show how LLM works; the Ted talk use stage visuals and narratives in the stage.</li>
</ol>
</section>
<section id="reasons-for-difference" class="level3">
<h3 class="anchored" data-anchor-id="reasons-for-difference">Reasons for difference</h3>
<ol type="1">
<li><p>News faces the mass and it needs vignette to attract the attention and maps to indicate the inequality in childcare access straightforwardly. Readers could get conclusions by reading the heat map. Lastly, at the end of the article we could input our post code, and then the scarcity of childcare resources will appear.</p></li>
<li><p>Blog post’s readers are mostly followers, who are general people, not experts in LLM. So the introduction of the interviewee could improve its authority and schematics could separate the steps how LLM works. Most importantly, the post blog break the process into plain words. It’s easier for readers to remember the process.</p></li>
<li><p>The Ted talk introduced many concepts and narratives to make the abstract concepts like prime number concrete. The stage could help impress the audience. Compared to the previous two forms, it reduced the audiences’ cognitive burden.</p></li>
</ol>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>